// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: data.sql

package db

import (
	"context"
)

const getAllCorr = `-- name: GetAllCorr :many
SELECT date, x0, x1, corr
FROM "corrpairs"
ORDER BY "date",
  "x0",
  "x1"
`

func (q *Queries) GetAllCorr(ctx context.Context) ([]Corrpair, error) {
	rows, err := q.db.QueryContext(ctx, getAllCorr)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Corrpair{}
	for rows.Next() {
		var i Corrpair
		if err := rows.Scan(
			&i.Date,
			&i.X0,
			&i.X1,
			&i.Corr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDate = `-- name: GetAllDate :many
SELECT DISTINCT "date"
FROM "modelparameters"
ORDER BY "date"
`

func (q *Queries) GetAllDate(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getAllDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var date string
		if err := rows.Scan(&date); err != nil {
			return nil, err
		}
		items = append(items, date)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllParam = `-- name: GetAllParam :many
SELECT date, ticker, sigma, alpha, beta, kappa, rho
FROM "modelparameters"
ORDER BY "date",
  "ticker"
`

func (q *Queries) GetAllParam(ctx context.Context) ([]Modelparameter, error) {
	rows, err := q.db.QueryContext(ctx, getAllParam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Modelparameter{}
	for rows.Next() {
		var i Modelparameter
		if err := rows.Scan(
			&i.Date,
			&i.Ticker,
			&i.Sigma,
			&i.Alpha,
			&i.Beta,
			&i.Kappa,
			&i.Rho,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllStats = `-- name: GetAllStats :many
SELECT date, ticker, index, mean, fixing
FROM "statistics"
ORDER BY "date",
  "ticker"
`

func (q *Queries) GetAllStats(ctx context.Context) ([]Statistic, error) {
	rows, err := q.db.QueryContext(ctx, getAllStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Statistic{}
	for rows.Next() {
		var i Statistic
		if err := rows.Scan(
			&i.Date,
			&i.Ticker,
			&i.Index,
			&i.Mean,
			&i.Fixing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCorr = `-- name: GetCorr :many
SELECT date, x0, x1, corr
FROM "corrpairs"
WHERE "date" in ($1)
ORDER BY "x0",
  "x1"
`

func (q *Queries) GetCorr(ctx context.Context, date string) ([]Corrpair, error) {
	rows, err := q.db.QueryContext(ctx, getCorr, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Corrpair{}
	for rows.Next() {
		var i Corrpair
		if err := rows.Scan(
			&i.Date,
			&i.X0,
			&i.X1,
			&i.Corr,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestCorrDate = `-- name: GetLatestCorrDate :one
SELECT DISTINCT "date"
FROM "corrpairs"
ORDER BY "date" DESC
LIMIT 1
`

func (q *Queries) GetLatestCorrDate(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getLatestCorrDate)
	var date string
	err := row.Scan(&date)
	return date, err
}

const getLatestParamDate = `-- name: GetLatestParamDate :one
SELECT DISTINCT "date"
FROM "modelparameters"
ORDER BY "date" DESC
LIMIT 1
`

func (q *Queries) GetLatestParamDate(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getLatestParamDate)
	var date string
	err := row.Scan(&date)
	return date, err
}

const getLatestPrice = `-- name: GetLatestPrice :many
SELECT "ticker",
  "fixing"
FROM "statistics"
WHERE "date" = (
    SELECT DISTINCT "date"
    FROM "statistics"
    ORDER BY "date" DESC
    LIMIT 1
  )
ORDER BY "ticker"
`

type GetLatestPriceRow struct {
	Ticker string  `json:"ticker"`
	Fixing float64 `json:"fixing"`
}

func (q *Queries) GetLatestPrice(ctx context.Context) ([]GetLatestPriceRow, error) {
	rows, err := q.db.QueryContext(ctx, getLatestPrice)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLatestPriceRow{}
	for rows.Next() {
		var i GetLatestPriceRow
		if err := rows.Scan(&i.Ticker, &i.Fixing); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestStatsDate = `-- name: GetLatestStatsDate :one
SELECT DISTINCT "date"
FROM "statistics"
ORDER BY "date" DESC
LIMIT 1
`

func (q *Queries) GetLatestStatsDate(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getLatestStatsDate)
	var date string
	err := row.Scan(&date)
	return date, err
}

const getParam = `-- name: GetParam :many
SELECT date, ticker, sigma, alpha, beta, kappa, rho
FROM "modelparameters"
WHERE "date" IN ($1)
`

func (q *Queries) GetParam(ctx context.Context, date string) ([]Modelparameter, error) {
	rows, err := q.db.QueryContext(ctx, getParam, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Modelparameter{}
	for rows.Next() {
		var i Modelparameter
		if err := rows.Scan(
			&i.Date,
			&i.Ticker,
			&i.Sigma,
			&i.Alpha,
			&i.Beta,
			&i.Kappa,
			&i.Rho,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStats = `-- name: GetStats :many
SELECT date, ticker, index, mean, fixing
FROM "statistics"
WHERE "date" IN ($1)
`

func (q *Queries) GetStats(ctx context.Context, date string) ([]Statistic, error) {
	rows, err := q.db.QueryContext(ctx, getStats, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Statistic{}
	for rows.Next() {
		var i Statistic
		if err := rows.Scan(
			&i.Date,
			&i.Ticker,
			&i.Index,
			&i.Mean,
			&i.Fixing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCorr = `-- name: InsertCorr :one
INSERT INTO "corrpairs" ("date", "x0", "x1", "corr")
VALUES ($1, $2, $3, $4)
RETURNING date, x0, x1, corr
`

type InsertCorrParams struct {
	Date string  `json:"date"`
	X0   string  `json:"x0"`
	X1   string  `json:"x1"`
	Corr float64 `json:"corr"`
}

func (q *Queries) InsertCorr(ctx context.Context, arg InsertCorrParams) (Corrpair, error) {
	row := q.db.QueryRowContext(ctx, insertCorr,
		arg.Date,
		arg.X0,
		arg.X1,
		arg.Corr,
	)
	var i Corrpair
	err := row.Scan(
		&i.Date,
		&i.X0,
		&i.X1,
		&i.Corr,
	)
	return i, err
}

const insertParam = `-- name: InsertParam :one
INSERT INTO "modelparameters" (
    "date",
    "ticker",
    "sigma",
    "alpha",
    "beta",
    "kappa",
    "rho"
  )
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING date, ticker, sigma, alpha, beta, kappa, rho
`

type InsertParamParams struct {
	Date   string  `json:"date"`
	Ticker string  `json:"ticker"`
	Sigma  float64 `json:"sigma"`
	Alpha  float64 `json:"alpha"`
	Beta   float64 `json:"beta"`
	Kappa  float64 `json:"kappa"`
	Rho    float64 `json:"rho"`
}

func (q *Queries) InsertParam(ctx context.Context, arg InsertParamParams) (Modelparameter, error) {
	row := q.db.QueryRowContext(ctx, insertParam,
		arg.Date,
		arg.Ticker,
		arg.Sigma,
		arg.Alpha,
		arg.Beta,
		arg.Kappa,
		arg.Rho,
	)
	var i Modelparameter
	err := row.Scan(
		&i.Date,
		&i.Ticker,
		&i.Sigma,
		&i.Alpha,
		&i.Beta,
		&i.Kappa,
		&i.Rho,
	)
	return i, err
}

const insertStat = `-- name: InsertStat :one
INSERT INTO "statistics" ("date", "ticker", "index", "mean", "fixing")
VALUES ($1, $2, $3, $4, $5)
RETURNING date, ticker, index, mean, fixing
`

type InsertStatParams struct {
	Date   string  `json:"date"`
	Ticker string  `json:"ticker"`
	Index  int32   `json:"index"`
	Mean   float64 `json:"mean"`
	Fixing float64 `json:"fixing"`
}

func (q *Queries) InsertStat(ctx context.Context, arg InsertStatParams) (Statistic, error) {
	row := q.db.QueryRowContext(ctx, insertStat,
		arg.Date,
		arg.Ticker,
		arg.Index,
		arg.Mean,
		arg.Fixing,
	)
	var i Statistic
	err := row.Scan(
		&i.Date,
		&i.Ticker,
		&i.Index,
		&i.Mean,
		&i.Fixing,
	)
	return i, err
}
